/**
 * The drive subsystem.
 * This contains methods for the arcade
 * @author Levi the Super Genius
 */

package frc.robot.subsystems;

import java.util.Map;
import java.util.function.BooleanSupplier;
import java.util.function.DoubleSupplier;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInLayouts;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardLayout;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Drive extends SubsystemBase {

    private final DifferentialDrive differentialDrive;
    private final SpeedController left = new SpeedControllerGroup(new WPI_TalonSRX(1), new WPI_TalonSRX(2));
    private final SpeedController right = new SpeedControllerGroup(new WPI_TalonSRX(3), new WPI_TalonSRX(4));
    public AHRS navx;
    private final ShuffleboardLayout layout;

    private int driveFace = 1;

    private final double DEADBAND_FORWARD = -.1;
    private final double DEADBAND_REVERSE = .1;
    private final double DEADBAND_RIGHT = -.15;
    private final double DEADBAND_LEFT = .15;
    private final double FORWARD_SPEED_SCALE = .7;
    private final double TWIST_SPEED_SCALE = .8;

    public Drive() {
        right.setInverted(true);
        differentialDrive = new DifferentialDrive(left, right);
        addChild("Differential Drive", differentialDrive);
        differentialDrive.setSafetyEnabled(false);
        differentialDrive.setExpiration(0.2);
        differentialDrive.setMaxOutput(1.0);

        // init navx
        try {
            navx = new AHRS(SPI.Port.kMXP, 57600, (byte) 60);
            navx.reset();
        } catch (RuntimeException exe) {
            DriverStation.reportError("NavX init failed- some autonomous components may not work right!", true);
        }

        layout = Shuffleboard.getTab("Subsystems").getLayout("NavX", BuiltInLayouts.kList);
        layout.withProperties(Map.of("Label position", "LEFT"));
        putToDashboard(); // put values onto dashboard

    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    /**
     * arcade drive for teleop period
     * 
     * @param speed joystick y
     * @param twist joystick z
     */

    public void arcadeDrive(double speed, double twist) {
        double outputSpeed, outputTwist;
        if (speed < DEADBAND_FORWARD || speed > DEADBAND_REVERSE)
            outputSpeed = speed * driveFace;
        else
            outputSpeed = 0;

        if (twist > DEADBAND_RIGHT || twist < DEADBAND_LEFT)
            outputTwist = speed * driveFace;
        else
            outputTwist = 0;

        differentialDrive.arcadeDrive(outputSpeed * FORWARD_SPEED_SCALE, outputTwist * TWIST_SPEED_SCALE);

    }

    /**
     * tank drive for autonomous
     * 
     * @param left  speed of left side
     * @param right speed of right side
     */

    public void tankDrive(double left, double right) {
        differentialDrive.tankDrive(left, right);
    }

    public void resetNavX() {
        navx.reset();
        navx.zeroYaw();
    }

    /**
     * returns the navx heading
     * 
     * @return navx yaw
     */

    public double getHeading() {
        return navx.getYaw();
    }

    /**
     * calculates distance using pythagorean theorem
     * 
     * @return distance since last reset
     */
    public double getDistance() {
        double up = navx.getDisplacementY(); // leg 1
        double acr = navx.getDisplacementX(); // leg 2
        double dist = Math.sqrt((up * up) + (acr * acr)); // hypotinuse
        return dist;
    }

    /**
     * calculates acceleration using pythagorean theorem
     * 
     * @return acceleration
     */
    public double getAcceleration() {
        float up = navx.getWorldLinearAccelX(); // leg 1
        float acr = navx.getWorldLinearAccelY(); // leg 2
        double accel = (double) Math.sqrt((up * up) + (acr * acr)); // hypotinuse
        return accel;
    }

    /**
     * Puts navX values on dashboard
     */
    private void putToDashboard() {
        final DoubleSupplier distanceSupplier = () -> getDistance();
        final DoubleSupplier yawSupplier = () -> navx.getYaw();
        final DoubleSupplier speedSupplier = () -> getAcceleration();
        final BooleanSupplier connectionSupplier = () -> navx.isConnected();
        final BooleanSupplier calibrationSupplier = () -> navx.isCalibrating();
        final BooleanSupplier toggleEngaged = () -> this.isToggleEngaged();

        layout.addNumber("distance", distanceSupplier);
        layout.addNumber("yaw", yawSupplier);
        layout.addNumber("acceleration", speedSupplier);
        layout.addBoolean("connected", connectionSupplier);
        layout.addBoolean("calibrating", calibrationSupplier);
        layout.addBoolean("toggle engaged", toggleEngaged);
    }

    public void stop() {
        tankDrive(0, 0);
    }

    public void toggleDrive() {
        driveFace = -driveFace;
    }

    public boolean isToggleEngaged() {
        if (driveFace == 1) {
            return false;
        }
        return true;

    }
}
